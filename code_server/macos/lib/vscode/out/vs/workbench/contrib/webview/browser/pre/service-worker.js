var p,g;const sw=self,VERSION=1,resourceCacheName=`vscode-resource-cache-${VERSION}`,rootPath=sw.location.pathname.replace(/\/service-worker.js$/,""),searchParams=new URL(location.toString()).searchParams,resourceOrigin=(p=searchParams.get("vscode-resource-origin"))!=null?p:sw.origin,resourceRoot=rootPath+"/vscode-resource",serviceWorkerFetchIgnoreSubdomain=(g=searchParams.get("serviceWorkerFetchIgnoreSubdomain"))!=null?g:!1,resolveTimeout=3e4;class RequestStore{constructor(){this.map=new Map,this.requestPool=0}get(e){const t=this.map.get(e);return t&&t.promise}create(){const e=++this.requestPool;let t;const o=new Promise(l=>t=l),s={resolve:t,promise:o};this.map.set(e,s);const i=()=>{if(clearTimeout(a),this.map.get(e)===s)return this.map.delete(e)},a=setTimeout(i,resolveTimeout);return{requestId:e,promise:o}}resolve(e,t){const o=this.map.get(e);return o?(o.resolve(t),this.map.delete(e),!0):!1}}const resourceRequestStore=new RequestStore,localhostRequestStore=new RequestStore,notFound=()=>new Response("Not Found",{status:404});sw.addEventListener("message",async n=>{switch(n.data.channel){case"version":{const e=n.source;sw.clients.get(e.id).then(t=>{t&&t.postMessage({channel:"version",version:VERSION})});return}case"did-load-resource":{let e;const t=n.data.data;switch(t.status){case 200:{e={type:"response",body:t.data,mime:t.mime,etag:t.etag};break}case 304:{e={type:"not-modified",mime:t.mime};break}}resourceRequestStore.resolve(t.id,e)||console.log("Could not resolve unknown resource",t.path);return}case"did-load-localhost":{const e=getWebviewIdForClient(n.source),t=n.data.data;localhostRequestStore.resolve(t.id,t.location)||console.log("Could not resolve unknown localhost",t.origin);return}}console.log("Unknown message")}),sw.addEventListener("fetch",n=>{const e=new URL(n.request.url);if(serviceWorkerFetchIgnoreSubdomain&&e.pathname.startsWith(resourceRoot+"/")){const t=/(.*):\/\/.*?\.(.*)/,o=resourceOrigin.match(t),s=e.origin.match(t);if(o&&s&&o[1]===s[1]&&o[2]===s[2])return n.respondWith(processResourceRequest(n,e))}else if(e.origin===resourceOrigin&&e.pathname.startsWith(resourceRoot+"/"))return n.respondWith(processResourceRequest(n,e));if(e.origin!==sw.origin&&e.host.match(/^(localhost|127.0.0.1|0.0.0.0):(\d+)$/))return n.respondWith(processLocalhostRequest(n,e))}),sw.addEventListener("install",n=>{n.waitUntil(sw.skipWaiting())}),sw.addEventListener("activate",n=>{n.waitUntil(sw.clients.claim())});async function processResourceRequest(n,e){const t=await sw.clients.get(n.clientId);if(!t)return console.log("Could not find inner client for request"),notFound();const o=getWebviewIdForClient(t),s=e.pathname.startsWith(resourceRoot+"/")?e.pathname.slice(resourceRoot.length):e.pathname;async function i(r,d){if(!r)return notFound();if(r.type==="not-modified"){if(d)return d.clone();throw new Error("No cache found")}const f=r.etag?{ETag:r.etag,"Cache-Control":"no-cache"}:{},m=new Response(r.body,{status:200,headers:{"Content-Type":r.mime,...f}});return r.etag&&caches.open(resourceCacheName).then(w=>w.put(n.request,m)),m.clone()}const a=await getOuterIframeClient(o);if(!a)return console.log("Could not find parent client for request"),notFound();const c=await(await caches.open(resourceCacheName)).match(n.request),{requestId:u,promise:h}=resourceRequestStore.create();return a.postMessage({channel:"load-resource",id:u,path:s,query:e.search.replace(/^\?/,""),ifNoneMatch:c==null?void 0:c.headers.get("ETag")}),h.then(r=>i(r,c))}async function processLocalhostRequest(n,e){const t=await sw.clients.get(n.clientId);if(!!t){const o=getWebviewIdForClient(t),s=e.origin,i=u=>{if(!u)return fetch(n.request);const h=n.request.url.replace(new RegExp(`^${e.origin}(/|$)`),`${u}$1`);return new Response(null,{status:302,headers:{Location:h}})},a=await getOuterIframeClient(o);if(!a)return console.log("Could not find parent client for request"),notFound();const{requestId:l,promise:c}=localhostRequestStore.create();return a.postMessage({channel:"load-localhost",origin:s,id:l}),c.then(i)}}function getWebviewIdForClient(n){return new URL(n.url).search.match(/\bid=([a-z0-9-]+)/i)[1]}async function getOuterIframeClient(n){return(await sw.clients.matchAll({includeUncontrolled:!0})).find(t=>{const o=new URL(t.url);return(o.pathname===`${rootPath}/`||o.pathname===`${rootPath}/index.html`||o.pathname===`${rootPath}/electron-browser-index.html`)&&o.search.match(new RegExp("\\bid="+n))})}

//# sourceMappingURL=service-worker.js.map
