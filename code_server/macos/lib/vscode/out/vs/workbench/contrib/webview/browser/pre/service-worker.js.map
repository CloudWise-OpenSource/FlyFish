{"version":3,"sources":["out-vscode/vs/workbench/contrib/webview/browser/pre/service-worker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// @ts-check\n\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"webworker\" />\n\nconst sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {any} */ (self));\n\nconst VERSION = 1;\n\nconst resourceCacheName = `vscode-resource-cache-${VERSION}`;\n\nconst rootPath = sw.location.pathname.replace(/\\/service-worker.js$/, '');\n\n\nconst searchParams = new URL(location.toString()).searchParams;\n/**\n * Origin used for resources\n */\nconst resourceOrigin = searchParams.get('vscode-resource-origin') ?? sw.origin;\n\n/**\n * Root path for resources\n */\nconst resourceRoot = rootPath + '/vscode-resource';\n\nconst serviceWorkerFetchIgnoreSubdomain = searchParams.get('serviceWorkerFetchIgnoreSubdomain') ?? false;\n\nconst resolveTimeout = 30000;\n\n/**\n * @template T\n * @typedef {{\n *     resolve: (x: T) => void,\n *     promise: Promise<T>\n * }} RequestStoreEntry\n */\n\n/**\n * Caches\n * @template T\n */\nclass RequestStore {\n\tconstructor() {\n\t\t/** @type {Map<number, RequestStoreEntry<T>>} */\n\t\tthis.map = new Map();\n\n\t\tthis.requestPool = 0;\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @return {Promise<T> | undefined}\n\t */\n\tget(requestId) {\n\t\tconst entry = this.map.get(requestId);\n\t\treturn entry && entry.promise;\n\t}\n\n\t/**\n\t * @returns {{ requestId: number, promise: Promise<T> }}\n\t */\n\tcreate() {\n\t\tconst requestId = ++this.requestPool;\n\n\t\tlet resolve;\n\t\tconst promise = new Promise(r => resolve = r);\n\t\tconst entry = { resolve, promise };\n\t\tthis.map.set(requestId, entry);\n\n\t\tconst dispose = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tconst existingEntry = this.map.get(requestId);\n\t\t\tif (existingEntry === entry) {\n\t\t\t\treturn this.map.delete(requestId);\n\t\t\t}\n\t\t};\n\t\tconst timeout = setTimeout(dispose, resolveTimeout);\n\t\treturn { requestId, promise };\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @param {T} result\n\t * @return {boolean}\n\t */\n\tresolve(requestId, result) {\n\t\tconst entry = this.map.get(requestId);\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\t\tentry.resolve(result);\n\t\tthis.map.delete(requestId);\n\t\treturn true;\n\t}\n}\n\n/**\n * Map of requested paths to responses.\n * @typedef {{ type: 'response', body: any, mime: string, etag: string | undefined, } | { type: 'not-modified', mime: string } | undefined} ResourceResponse\n * @type {RequestStore<ResourceResponse>}\n */\nconst resourceRequestStore = new RequestStore();\n\n/**\n * Map of requested localhost origins to optional redirects.\n *\n * @type {RequestStore<string | undefined>}\n */\nconst localhostRequestStore = new RequestStore();\n\nconst notFound = () =>\n\tnew Response('Not Found', { status: 404, });\n\nsw.addEventListener('message', async (event) => {\n\tswitch (event.data.channel) {\n\t\tcase 'version':\n\t\t\t{\n\t\t\t\tconst source = /** @type {Client} */ (event.source);\n\t\t\t\tsw.clients.get(source.id).then(client => {\n\t\t\t\t\tif (client) {\n\t\t\t\t\t\tclient.postMessage({\n\t\t\t\t\t\t\tchannel: 'version',\n\t\t\t\t\t\t\tversion: VERSION\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\tcase 'did-load-resource':\n\t\t\t{\n\t\t\t\t/** @type {ResourceResponse} */\n\t\t\t\tlet response = undefined;\n\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tswitch (data.status) {\n\t\t\t\t\tcase 200:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresponse = { type: 'response', body: data.data, mime: data.mime, etag: data.etag };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 304:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresponse = { type: 'not-modified', mime: data.mime };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!resourceRequestStore.resolve(data.id, response)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown resource', data.path);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\tcase 'did-load-localhost':\n\t\t\t{\n\t\t\t\tconst webviewId = getWebviewIdForClient(event.source);\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tif (!localhostRequestStore.resolve(data.id, data.location)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown localhost', data.origin);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\tconsole.log('Unknown message');\n});\n\nsw.addEventListener('fetch', (event) => {\n\tconst requestUrl = new URL(event.request.url);\n\n\tif (serviceWorkerFetchIgnoreSubdomain && requestUrl.pathname.startsWith(resourceRoot + '/')) {\n\t\t// #121981\n\t\tconst ignoreFirstSubdomainRegex = /(.*):\\/\\/.*?\\.(.*)/;\n\t\tconst match1 = resourceOrigin.match(ignoreFirstSubdomainRegex);\n\t\tconst match2 = requestUrl.origin.match(ignoreFirstSubdomainRegex);\n\t\tif (match1 && match2 && match1[1] === match2[1] && match1[2] === match2[2]) {\n\t\t\treturn event.respondWith(processResourceRequest(event, requestUrl));\n\t\t}\n\t} else if (requestUrl.origin === resourceOrigin && requestUrl.pathname.startsWith(resourceRoot + '/')) {\n\t\t// See if it's a resource request\n\t\treturn event.respondWith(processResourceRequest(event, requestUrl));\n\t}\n\n\t// See if it's a localhost request\n\tif (requestUrl.origin !== sw.origin && requestUrl.host.match(/^(localhost|127.0.0.1|0.0.0.0):(\\d+)$/)) {\n\t\treturn event.respondWith(processLocalhostRequest(event, requestUrl));\n\t}\n});\n\nsw.addEventListener('install', (event) => {\n\tevent.waitUntil(sw.skipWaiting()); // Activate worker immediately\n});\n\nsw.addEventListener('activate', (event) => {\n\tevent.waitUntil(sw.clients.claim()); // Become available to all pages\n});\n\n/**\n * @param {FetchEvent} event\n * @param {URL} requestUrl\n */\nasync function processResourceRequest(event, requestUrl) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\tconsole.log('Could not find inner client for request');\n\t\treturn notFound();\n\t}\n\n\tconst webviewId = getWebviewIdForClient(client);\n\tconst resourcePath = requestUrl.pathname.startsWith(resourceRoot + '/') ? requestUrl.pathname.slice(resourceRoot.length) : requestUrl.pathname;\n\n\t/**\n\t * @param {ResourceResponse} entry\n\t * @param {Response | undefined} cachedResponse\n\t */\n\tasync function resolveResourceEntry(entry, cachedResponse) {\n\t\tif (!entry) {\n\t\t\treturn notFound();\n\t\t}\n\n\t\tif (entry.type === 'not-modified') {\n\t\t\tif (cachedResponse) {\n\t\t\t\treturn cachedResponse.clone();\n\t\t\t} else {\n\t\t\t\tthrow new Error('No cache found');\n\t\t\t}\n\t\t}\n\n\t\tconst cacheHeaders = entry.etag ? {\n\t\t\t'ETag': entry.etag,\n\t\t\t'Cache-Control': 'no-cache'\n\t\t} : {};\n\n\t\tconst response = new Response(entry.body, {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t'Content-Type': entry.mime,\n\t\t\t\t...cacheHeaders\n\t\t\t}\n\t\t});\n\n\t\tif (entry.etag) {\n\t\t\tcaches.open(resourceCacheName).then(cache => {\n\t\t\t\treturn cache.put(event.request, response);\n\t\t\t});\n\t\t}\n\t\treturn response.clone();\n\t}\n\n\tconst parentClient = await getOuterIframeClient(webviewId);\n\tif (!parentClient) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\tconst cache = await caches.open(resourceCacheName);\n\tconst cached = await cache.match(event.request);\n\n\tconst { requestId, promise } = resourceRequestStore.create();\n\tparentClient.postMessage({\n\t\tchannel: 'load-resource',\n\t\tid: requestId,\n\t\tpath: resourcePath,\n\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\tifNoneMatch: cached?.headers.get('ETag'),\n\t});\n\n\treturn promise.then(entry => resolveResourceEntry(entry, cached));\n}\n\n/**\n * @param {*} event\n * @param {URL} requestUrl\n */\nasync function processLocalhostRequest(event, requestUrl) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\t// This is expected when requesting resources on other localhost ports\n\t\t// that are not spawned by vs code\n\t\treturn undefined;\n\t}\n\tconst webviewId = getWebviewIdForClient(client);\n\tconst origin = requestUrl.origin;\n\n\t/**\n\t * @param {string} redirectOrigin\n\t */\n\tconst resolveRedirect = (redirectOrigin) => {\n\t\tif (!redirectOrigin) {\n\t\t\treturn fetch(event.request);\n\t\t}\n\t\tconst location = event.request.url.replace(new RegExp(`^${requestUrl.origin}(/|$)`), `${redirectOrigin}$1`);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: location\n\t\t\t}\n\t\t});\n\t};\n\n\tconst parentClient = await getOuterIframeClient(webviewId);\n\tif (!parentClient) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\tconst { requestId, promise } = localhostRequestStore.create();\n\tparentClient.postMessage({\n\t\tchannel: 'load-localhost',\n\t\torigin: origin,\n\t\tid: requestId,\n\t});\n\n\treturn promise.then(resolveRedirect);\n}\n\nfunction getWebviewIdForClient(client) {\n\tconst requesterClientUrl = new URL(client.url);\n\treturn requesterClientUrl.search.match(/\\bid=([a-z0-9-]+)/i)[1];\n}\n\nasync function getOuterIframeClient(webviewId) {\n\tconst allClients = await sw.clients.matchAll({ includeUncontrolled: true });\n\treturn allClients.find(client => {\n\t\tconst clientUrl = new URL(client.url);\n\t\tconst hasExpectedPathName = (clientUrl.pathname === `${rootPath}/` || clientUrl.pathname === `${rootPath}/index.html` || clientUrl.pathname === `${rootPath}/electron-browser-index.html`);\n\t\treturn hasExpectedPathName && clientUrl.search.match(new RegExp('\\\\bid=' + webviewId));\n\t});\n}\n"],"mappings":"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","names":[],"file":"service-worker.js"}