(function(){"use strict";function N(g,i,s,c){function v(t){return new Promise(n=>s.exists(t,n))}function D(t){return new Promise((n,r)=>{const e=new Date;s.utimes(t,e,e,o=>o?r(o):n())})}function I(t){return new Promise((n,r)=>s.mkdir(t,{recursive:!0},e=>e&&e.code!=="EEXIST"?r(e):n(t)))}function M(t){return new Promise((n,r)=>s.rmdir(t,{recursive:!0},e=>e&&e.code!=="ENOENT"?r(e):n()))}function F(t){return new Promise((n,r)=>s.readFile(t,"utf8",(e,o)=>e?r(e):n(o)))}function O(t,n){return new Promise((r,e)=>s.writeFile(t,n,"utf8",o=>o?e(o):r()))}function T(t){const n=i.join(t,"languagepacks.json");try{return JSON.parse(s.readFileSync(n,"utf8"))}catch(r){}}function V(t,n){try{for(;n;){if(t[n])return n;{const r=n.lastIndexOf("-");if(r>0)n=n.substring(0,r);else return}}}catch(r){console.error("Resolving language pack configuration failed.",r)}}function U(t,n,r,e){if(e==="pseudo")return Promise.resolve({locale:e,availableLanguages:{},pseudo:!0});if(process.env.VSCODE_DEV)return Promise.resolve({locale:e,availableLanguages:{}});if(e&&(e==="en"||e==="en-us"))return Promise.resolve({locale:e,availableLanguages:{}});const o=e;c.mark("code/willGenerateNls");const u=function(a){return c.mark("code/didGenerateNls"),Promise.resolve({locale:a,availableLanguages:{}})};try{if(!t)return u(o);const a=T(n);if(!a||(e=V(a,e),!e))return u(o);const f=a[e];let P;return!f||typeof f.hash!="string"||!f.translations||typeof(P=f.translations.vscode)!="string"?u(o):v(P).then(X=>{if(!X)return u(o);const S=f.hash+"."+e,l=i.join(n,"clp",S),d=i.join(l,t),_=i.join(l,"tcf.json"),q=i.join(l,"corrupted.info"),x={locale:o,availableLanguages:{"*":e},_languagePackId:S,_translationsConfigFile:_,_cacheRoot:l,_resolvedLanguagePackCoreLocation:d,_corruptedFile:q};return v(q).then($=>{let b;return $?b=M(l):b=Promise.resolve(void 0),b.then(()=>v(d).then(z=>z?(D(d).catch(()=>{}),c.mark("code/didGenerateNls"),x):I(d).then(()=>Promise.all([F(r),F(P)])).then(m=>{const p=JSON.parse(m[0]),A=JSON.parse(m[1]).contents,B=Object.keys(p.bundles),w=[];for(const C of B){const H=p.bundles[C],E=Object.create(null);for(const h of H){const G=p.keys[h],R=p.messages[h],J=A[h];let k;if(J){k=[];for(let y=0;y<G.length;y++){const j=G[y],K=typeof j=="string"?j:j.key;let L=J[K];L===void 0&&(L=R[y]),k.push(L)}}else k=R;E[h]=k}w.push(O(i.join(d,C.replace(/\//g,"!")+".nls.json"),JSON.stringify(E)))}return w.push(O(_,JSON.stringify(f.translations))),Promise.all(w)}).then(()=>(c.mark("code/didGenerateNls"),x)).catch(m=>(console.error("Generating translation files failed.",m),u(e)))))})})}catch(a){return console.error("Generating translation files failed.",a),u(e)}}return{getNLSConfiguration:U}}if(typeof define=="function")define(["require","path","fs","vs/base/common/performance"],function(g,i,s,c){return N(g.__$__nodeRequire,i,s,c)});else if(typeof module=="object"&&typeof module.exports=="object"){const g=require("path"),i=require("fs"),s=require("../common/performance");module.exports=N(require,g,i,s)}else throw new Error("Unknown context")})();

//# sourceMappingURL=languagePacks.js.map
