{"version":3,"sources":["out-vscode/vs/workbench/contrib/webview/browser/pre/service-worker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// @ts-check\n\n/// <reference no-default-lib=\"true\"/>\n/// <reference lib=\"webworker\" />\n\nconst sw = /** @type {ServiceWorkerGlobalScope} */ (/** @type {any} */ (self));\n\nconst VERSION = 2;\n\nconst resourceCacheName = `vscode-resource-cache-${VERSION}`;\n\nconst rootPath = sw.location.pathname.replace(/\\/service-worker.js$/, '');\n\n\nconst searchParams = new URL(location.toString()).searchParams;\n\n/**\n * Origin used for resources\n */\nconst resourceBaseAuthority = searchParams.get('vscode-resource-base-authority');\n\nconst resolveTimeout = 30000;\n\n/**\n * @template T\n * @typedef {{\n *     resolve: (x: T) => void,\n *     promise: Promise<T>\n * }} RequestStoreEntry\n */\n\n/**\n * Caches\n * @template T\n */\nclass RequestStore {\n\tconstructor() {\n\t\t/** @type {Map<number, RequestStoreEntry<T>>} */\n\t\tthis.map = new Map();\n\n\t\tthis.requestPool = 0;\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @return {Promise<T> | undefined}\n\t */\n\tget(requestId) {\n\t\tconst entry = this.map.get(requestId);\n\t\treturn entry && entry.promise;\n\t}\n\n\t/**\n\t * @returns {{ requestId: number, promise: Promise<T> }}\n\t */\n\tcreate() {\n\t\tconst requestId = ++this.requestPool;\n\n\t\t/** @type {undefined | ((x: T) => void)} */\n\t\tlet resolve;\n\n\t\t/** @type {Promise<T>} */\n\t\tconst promise = new Promise(r => resolve = r);\n\n\t\t/** @type {RequestStoreEntry<T>} */\n\t\tconst entry = { resolve: /** @type {(x: T) => void} */ (resolve), promise };\n\n\t\tthis.map.set(requestId, entry);\n\n\t\tconst dispose = () => {\n\t\t\tclearTimeout(timeout);\n\t\t\tconst existingEntry = this.map.get(requestId);\n\t\t\tif (existingEntry === entry) {\n\t\t\t\treturn this.map.delete(requestId);\n\t\t\t}\n\t\t};\n\t\tconst timeout = setTimeout(dispose, resolveTimeout);\n\t\treturn { requestId, promise };\n\t}\n\n\t/**\n\t * @param {number} requestId\n\t * @param {T} result\n\t * @return {boolean}\n\t */\n\tresolve(requestId, result) {\n\t\tconst entry = this.map.get(requestId);\n\t\tif (!entry) {\n\t\t\treturn false;\n\t\t}\n\t\tentry.resolve(result);\n\t\tthis.map.delete(requestId);\n\t\treturn true;\n\t}\n}\n\n/**\n * Map of requested paths to responses.\n * @typedef {{ type: 'response', body: any, mime: string, etag: string | undefined, } | { type: 'not-modified', mime: string } | undefined} ResourceResponse\n * @type {RequestStore<ResourceResponse>}\n */\nconst resourceRequestStore = new RequestStore();\n\n/**\n * Map of requested localhost origins to optional redirects.\n *\n * @type {RequestStore<string | undefined>}\n */\nconst localhostRequestStore = new RequestStore();\n\nconst notFound = () =>\n\tnew Response('Not Found', { status: 404, });\n\nsw.addEventListener('message', async (event) => {\n\tswitch (event.data.channel) {\n\t\tcase 'version':\n\t\t\t{\n\t\t\t\tconst source = /** @type {Client} */ (event.source);\n\t\t\t\tsw.clients.get(source.id).then(client => {\n\t\t\t\t\tif (client) {\n\t\t\t\t\t\tclient.postMessage({\n\t\t\t\t\t\t\tchannel: 'version',\n\t\t\t\t\t\t\tversion: VERSION\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\tcase 'did-load-resource':\n\t\t\t{\n\t\t\t\t/** @type {ResourceResponse} */\n\t\t\t\tlet response = undefined;\n\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tswitch (data.status) {\n\t\t\t\t\tcase 200:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresponse = { type: 'response', body: data.data, mime: data.mime, etag: data.etag };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 304:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresponse = { type: 'not-modified', mime: data.mime };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!resourceRequestStore.resolve(data.id, response)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown resource', data.path);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\tcase 'did-load-localhost':\n\t\t\t{\n\t\t\t\tconst data = event.data.data;\n\t\t\t\tif (!localhostRequestStore.resolve(data.id, data.location)) {\n\t\t\t\t\tconsole.log('Could not resolve unknown localhost', data.origin);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\n\tconsole.log('Unknown message');\n});\n\nsw.addEventListener('fetch', (event) => {\n\tconst requestUrl = new URL(event.request.url);\n\tif (requestUrl.protocol === 'https:' && requestUrl.hostname.endsWith('.' + resourceBaseAuthority)) {\n\t\treturn event.respondWith(processResourceRequest(event, requestUrl));\n\t}\n\n\t// See if it's a localhost request\n\tif (requestUrl.origin !== sw.origin && requestUrl.host.match(/^(localhost|127.0.0.1|0.0.0.0):(\\d+)$/)) {\n\t\treturn event.respondWith(processLocalhostRequest(event, requestUrl));\n\t}\n});\n\nsw.addEventListener('install', (event) => {\n\tevent.waitUntil(sw.skipWaiting()); // Activate worker immediately\n});\n\nsw.addEventListener('activate', (event) => {\n\tevent.waitUntil(sw.clients.claim()); // Become available to all pages\n});\n\n/**\n * @param {FetchEvent} event\n * @param {URL} requestUrl\n */\nasync function processResourceRequest(event, requestUrl) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\tconsole.error('Could not find inner client for request');\n\t\treturn notFound();\n\t}\n\n\tconst webviewId = getWebviewIdForClient(client);\n\tif (!webviewId) {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn notFound();\n\t}\n\n\t/**\n\t * @param {ResourceResponse} entry\n\t * @param {Response | undefined} cachedResponse\n\t */\n\tasync function resolveResourceEntry(entry, cachedResponse) {\n\t\tif (!entry) {\n\t\t\treturn notFound();\n\t\t}\n\n\t\tif (entry.type === 'not-modified') {\n\t\t\tif (cachedResponse) {\n\t\t\t\treturn cachedResponse.clone();\n\t\t\t} else {\n\t\t\t\tthrow new Error('No cache found');\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Record<String, string>} */\n\t\tconst headers = {\n\t\t\t'Content-Type': entry.mime,\n\t\t\t'Access-Control-Allow-Origin': '*',\n\t\t};\n\t\tif (entry.etag) {\n\t\t\theaders['ETag'] = entry.etag;\n\t\t\theaders['Cache-Control'] = 'no-cache';\n\t\t}\n\t\tconst response = new Response(entry.body, {\n\t\t\tstatus: 200,\n\t\t\theaders\n\t\t});\n\n\t\tif (entry.etag) {\n\t\t\tcaches.open(resourceCacheName).then(cache => {\n\t\t\t\treturn cache.put(event.request, response);\n\t\t\t});\n\t\t}\n\t\treturn response.clone();\n\t}\n\n\tconst parentClients = await getOuterIframeClient(webviewId);\n\tif (!parentClients.length) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\tconst cache = await caches.open(resourceCacheName);\n\tconst cached = await cache.match(event.request);\n\n\tconst { requestId, promise } = resourceRequestStore.create();\n\n\tconst firstHostSegment = requestUrl.hostname.slice(0, requestUrl.hostname.length - (resourceBaseAuthority.length + 1));\n\tconst scheme = firstHostSegment.split('+', 1)[0];\n\tconst authority = firstHostSegment.slice(scheme.length + 1) + requestUrl.port ? (':' + requestUrl.port) : ''; // may be empty\n\n\tfor (const parentClient of parentClients) {\n\t\tparentClient.postMessage({\n\t\t\tchannel: 'load-resource',\n\t\t\tid: requestId,\n\t\t\tpath: requestUrl.pathname,\n\t\t\tscheme,\n\t\t\tauthority,\n\t\t\tquery: requestUrl.search.replace(/^\\?/, ''),\n\t\t\tifNoneMatch: cached?.headers.get('ETag'),\n\t\t});\n\t}\n\n\treturn promise.then(entry => resolveResourceEntry(entry, cached));\n}\n\n/**\n * @param {FetchEvent} event\n * @param {URL} requestUrl\n * @return {Promise<Response>}\n */\nasync function processLocalhostRequest(event, requestUrl) {\n\tconst client = await sw.clients.get(event.clientId);\n\tif (!client) {\n\t\t// This is expected when requesting resources on other localhost ports\n\t\t// that are not spawned by vs code\n\t\treturn fetch(event.request);\n\t}\n\tconst webviewId = getWebviewIdForClient(client);\n\tif (!webviewId) {\n\t\tconsole.error('Could not resolve webview id');\n\t\treturn fetch(event.request);\n\t}\n\n\tconst origin = requestUrl.origin;\n\n\t/**\n\t * @param {string | undefined} redirectOrigin\n\t * @return {Promise<Response>}\n\t */\n\tconst resolveRedirect = async (redirectOrigin) => {\n\t\tif (!redirectOrigin) {\n\t\t\treturn fetch(event.request);\n\t\t}\n\t\tconst location = event.request.url.replace(new RegExp(`^${requestUrl.origin}(/|$)`), `${redirectOrigin}$1`);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: location\n\t\t\t}\n\t\t});\n\t};\n\n\tconst parentClients = await getOuterIframeClient(webviewId);\n\tif (!parentClients.length) {\n\t\tconsole.log('Could not find parent client for request');\n\t\treturn notFound();\n\t}\n\n\tconst { requestId, promise } = localhostRequestStore.create();\n\tfor (const parentClient of parentClients) {\n\t\tparentClient.postMessage({\n\t\t\tchannel: 'load-localhost',\n\t\t\torigin: origin,\n\t\t\tid: requestId,\n\t\t});\n\t}\n\n\treturn promise.then(resolveRedirect);\n}\n\n/**\n * @param {Client} client\n * @returns {string | null}\n */\nfunction getWebviewIdForClient(client) {\n\tconst requesterClientUrl = new URL(client.url);\n\treturn requesterClientUrl.searchParams.get('id');\n}\n\n/**\n * @param {string} webviewId\n * @returns {Promise<Client[]>}\n */\nasync function getOuterIframeClient(webviewId) {\n\tconst allClients = await sw.clients.matchAll({ includeUncontrolled: true });\n\treturn allClients.filter(client => {\n\t\tconst clientUrl = new URL(client.url);\n\t\tconst hasExpectedPathName = (clientUrl.pathname === `${rootPath}/` || clientUrl.pathname === `${rootPath}/index.html` || clientUrl.pathname === `${rootPath}/electron-browser-index.html`);\n\t\treturn hasExpectedPathName && clientUrl.searchParams.get('id') === webviewId;\n\t});\n}\n"],"mappings":"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","names":[],"file":"service-worker.js"}