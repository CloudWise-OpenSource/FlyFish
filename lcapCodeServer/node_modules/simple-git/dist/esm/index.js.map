{
  "version": 3,
  "sources": ["../../src/lib/errors/git-error.ts", "../../src/lib/errors/git-response-error.ts", "../../src/lib/errors/task-configuration-error.ts", "../../src/lib/utils/util.ts", "../../src/lib/utils/argument-filters.ts", "../../src/lib/utils/exit-codes.ts", "../../src/lib/utils/git-output-streams.ts", "../../src/lib/utils/line-parser.ts", "../../src/lib/utils/simple-git-options.ts", "../../src/lib/utils/task-options.ts", "../../src/lib/utils/task-parser.ts", "../../src/lib/utils/index.ts", "../../src/lib/tasks/check-is-repo.ts", "../../src/lib/responses/CleanSummary.ts", "../../src/lib/tasks/task.ts", "../../src/lib/tasks/clean.ts", "../../src/lib/responses/ConfigList.ts", "../../src/lib/tasks/config.ts", "../../src/lib/tasks/grep.ts", "../../src/lib/tasks/reset.ts", "../../src/lib/git-logger.ts", "../../src/lib/runners/tasks-pending-queue.ts", "../../src/lib/runners/git-executor-chain.ts", "../../src/lib/runners/git-executor.ts", "../../src/lib/task-callback.ts", "../../src/lib/tasks/change-working-directory.ts", "../../src/lib/tasks/hash-object.ts", "../../src/lib/responses/InitSummary.ts", "../../src/lib/tasks/init.ts", "../../src/lib/responses/DiffSummary.ts", "../../src/lib/parsers/parse-diff-summary.ts", "../../src/lib/parsers/parse-list-log-summary.ts", "../../src/lib/tasks/log.ts", "../../src/lib/responses/MergeSummary.ts", "../../src/lib/responses/PullSummary.ts", "../../src/lib/parsers/parse-remote-objects.ts", "../../src/lib/parsers/parse-remote-messages.ts", "../../src/lib/parsers/parse-pull.ts", "../../src/lib/parsers/parse-merge.ts", "../../src/lib/tasks/merge.ts", "../../src/lib/parsers/parse-push.ts", "../../src/lib/tasks/push.ts", "../../src/lib/responses/FileStatusSummary.ts", "../../src/lib/responses/StatusSummary.ts", "../../src/lib/tasks/status.ts", "../../src/lib/simple-git-api.ts", "../../src/lib/runners/scheduler.ts", "../../src/lib/tasks/apply-patch.ts", "../../src/lib/responses/BranchDeleteSummary.ts", "../../src/lib/parsers/parse-branch-delete.ts", "../../src/lib/responses/BranchSummary.ts", "../../src/lib/parsers/parse-branch.ts", "../../src/lib/tasks/branch.ts", "../../src/lib/responses/CheckIgnore.ts", "../../src/lib/tasks/check-ignore.ts", "../../src/lib/tasks/clone.ts", "../../src/lib/parsers/parse-commit.ts", "../../src/lib/tasks/commit.ts", "../../src/lib/tasks/diff.ts", "../../src/lib/parsers/parse-fetch.ts", "../../src/lib/tasks/fetch.ts", "../../src/lib/parsers/parse-move.ts", "../../src/lib/tasks/move.ts", "../../src/lib/tasks/pull.ts", "../../src/lib/responses/GetRemoteSummary.ts", "../../src/lib/tasks/remote.ts", "../../src/lib/tasks/stash-list.ts", "../../src/lib/tasks/sub-module.ts", "../../src/lib/responses/TagList.ts", "../../src/lib/tasks/tag.ts", "../../src/git.js", "../../src/lib/errors/git-construct-error.ts", "../../src/lib/api.ts", "../../src/lib/errors/git-plugin-error.ts", "../../src/lib/plugins/command-config-prefixing-plugin.ts", "../../src/lib/plugins/completion-detection.plugin.ts", "../../src/lib/plugins/error-detection.plugin.ts", "../../src/lib/plugins/plugin-store.ts", "../../src/lib/plugins/progress-monitor-plugin.ts", "../../src/lib/plugins/spawn-options-plugin.ts", "../../src/lib/plugins/timout-plugin.ts", "../../src/lib/git-factory.ts", "../../src/lib/runners/promise-wrapped.ts", "../../src/esm.mjs"],
  "sourcesContent": ["import { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      message?: string,\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string,\n   ) {\n      super(undefined, message || String(git));\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n\n   constructor (\n      message?: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {\n};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return (typeof source === 'function' && source !== NOOP);\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [\n      input.substr(0, index),\n      input.substr(index + 1),\n   ];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator)\n      .reduce((output, line) => {\n         const lineContent = trimmed ? line.trim() : line;\n         if (lineContent) {\n            output.push(lineContent);\n         }\n         return output;\n      }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(input: string, callback: LineWithContentCallback<T>): T[] {\n   return toLinesWithContent(input, true).map(line => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (input: any) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign({}, ...properties.map((property) => property in source ? {[property]: source[property]} : {}));\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise(done => setTimeout(done, duration));\n}\n", "import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return (arguments.length > 2) ? def : undefined\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n}\n\nexport function filterPrimitives(input: unknown, omit?: Array<'boolean' | 'string' | 'number'>): input is Primitives {\n   return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input) as 'boolean' | 'string' | 'number'));\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (input): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (input): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n}\n", "/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   UNCLEAN = 128,\n}\n", "import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n\n   constructor(public readonly stdOut: T, public readonly stdErr: T) {\n   }\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n", "export class LineParser<T> {\n\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void,\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => (string | undefined), target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   }\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n};\n\nexport function createInstanceConfig(...options: Array<Partial<SimpleGitOptions> | undefined>): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign({baseDir, ...defaultOptions},\n      ...(options.filter(o => typeof o === 'object' && o))\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n\n   return config;\n}\n", "import { filterArray, filterFunction, filterPlainObject, filterPrimitives, filterType } from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\n\nexport function appendTaskOptions<T extends Options = Options>(options: Maybe<T>, commands: string[] = []): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(args: IArguments, initialPrimitive = 0, objectOnly = false): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(\n      last(args, hasTrailingCallback ? 1 : 0), filterArray, []\n   );\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(args: unknown[] | IArguments | unknown, includeNoop = true): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n", "import { TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(result: T, parsers: LineParser<T>[], ...texts: string[]): T {\n   texts.forEach(text => {\n      for (let lines = toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if ((i + offset) >= max) {\n               return;\n            }\n            return lines[i + offset];\n         }\n\n         parsers.some(({parse}) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n", "\nexport * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n", "import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({exitCode}, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n}\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n}\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   }\n}\n\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n", "import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(\n      public readonly dryRun: boolean,\n   ) {}\n\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser (dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach(line => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n", "import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty',\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      }\n   }\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   }\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   }\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n", "import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set(['i', ...asStringArray(Object.values(CleanOptions as any))]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const {cleanMode, options, valid} = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      }\n   }\n}\n\nexport function isCleanOptionsArray (input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = {cleanMode: false, options: true};\n\n   input.replace(/[^a-z]i/g, '').split('').forEach(char => {\n      if (isCleanMode(char)) {\n         cleanMode = char;\n         valid.cleanMode = true;\n      }\n      else {\n         valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));\n      }\n   });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   }\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n", "import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {}\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push(value = item.value);\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max;) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield {file, key, value};\n   }\n}\n", "import { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(scope: GitConfigScope | unknown, fallback: T): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(key: string, value: string, append: boolean, scope: GitConfigScope): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      }\n   }\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      }\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   }\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments),\n         )\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n   };\n}\n", "import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   * [Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then,\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask({\n            commands,\n            format: 'utf-8',\n            parser(stdOut) {\n               return parseGrep(stdOut);\n            },\n         }, then);\n      }\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n", "import debug, { Debugger } from 'debug';\nimport { append, filterHasLength, filterString, filterType, NOOP, objectToString, remove } from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n}\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog () {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step (nextStep?: string): OutputLogger;\n   sibling (name: string): OutputLogger;\n}\n\nfunction prefixedLogger (to: Debugger, prefix: string, forward?: OutputLoggingHandler): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward ? to : (message, ...args) => {\n         to(message, ...args);\n         forward(message, ...args);\n      };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName (name: Maybe<string>, childDebugger: Maybe<Debugger>, {namespace: parentNamespace}: Debugger): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = childDebugger && childDebugger.namespace || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger (label: string, verbose?: string | Debugger, initialStep?: string, infoDebugger = createLog()): OutputLogger {\n   const labelPrefix = label && `[${label}]` || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = phase && `[${phase}]` || '';\n      const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${ stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent (silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const {namespace} = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter(s => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         }\n         else {\n            env.push(namespace);\n         }\n      }\n      else {\n         if (hasOn) {\n            remove(env, namespace);\n         }\n         else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n\n}\n", "import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n}\n\nexport class TasksPendingQueue {\n\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {\n   }\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress (task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, {logger}] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n         } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName (name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n", "import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask, } from '../tasks/task';\nimport { GitExecutorResult, Maybe, outputHandler, RunnableTask, SimpleGitExecutor, SimpleGitTask } from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {\n   }\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return this._chain = this._chain.then(() => this.attemptTask(task));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const {logger} = this._queue.attempt(task);\n         return await (isEmptyTask(task)\n               ? this.attemptEmptyTask(task, logger)\n               : this.attemptRemoteTask(task, logger)\n         ) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError = (e instanceof GitError) ? Object.assign(e, {task}) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary, args, this.outputHandler, logger.step('SPAWN'),\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult, logger: OutputLogger): Promise<GitOutputStreams> {\n\n      const {exitCode, rejection, stdOut, stdErr} = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const {error} = this._plugins.exec('task.error', {error: rejection}, {\n            ...pluginContext(task, args),\n            ...result,\n         });\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(new GitOutputStreams(\n                     Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                     Buffer.concat(stdErr),\n                  ));\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(\n            Buffer.concat(stdOut),\n            Buffer.concat(stdErr),\n         ));\n      });\n   }\n\n   private async gitResponse<R>(task: SimpleGitTask<R>, command: string, args: string[], outputHandler: Maybe<outputHandler>, logger: OutputLogger): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec('spawn.options', {\n         cwd: this.cwd,\n         env: this.env,\n         windowsHide: true,\n      }, pluginContext(task, task.commands));\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         let rejection: Maybe<Error>;\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions)\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));\n         spawned.stderr!.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   }\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   }\n}\n\nfunction onDataReceived(target: Buffer[], name: string, logger: OutputLogger, output: OutputLogger) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer)\n   }\n}\n", "import { PluginStore } from '../plugins';\nimport { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore,\n   ) {\n   }\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n\n}\n\n\n", "import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(task: SimpleGitTask<R>, response: Promise<R>, callback: SimpleGitTaskCallback<R> = NOOP) {\n\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback((err instanceof GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined as any);\n      }\n   };\n\n   response.then(onSuccess, onError);\n\n}\n\nfunction addDeprecationNoticeToError (err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get () {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n", "import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask (directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${ directory }\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n", "import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n", "import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string,\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n", "import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      }\n   }\n}\n", "import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n", "import { DiffResult } from '../../../typings';\nimport { DiffSummary } from '../responses/DiffSummary';\n\nexport function parseDiffResult(stdOut: string): DiffResult {\n   const lines = stdOut.trim().split('\\n');\n   const status = new DiffSummary();\n   readSummaryLine(status, lines.pop());\n\n   for (let i = 0, max = lines.length; i < max; i++) {\n      const line = lines[i];\n      textFileChange(line, status) || binaryFileChange(line, status);\n   }\n\n   return status;\n}\n\nfunction readSummaryLine(status: DiffResult, summary?: string) {\n   (summary || '')\n      .trim()\n      .split(', ')\n      .forEach(function (text: string) {\n         const summary = /(\\d+)\\s([a-z]+)/.exec(text);\n         if (!summary) {\n            return;\n         }\n\n         summaryType(status, summary[2], parseInt(summary[1], 10));\n      });\n}\n\nfunction summaryType (status: DiffResult, key: string, value: number) {\n   const match = (/([a-z]+?)s?\\b/.exec(key));\n   if (!match || !statusUpdate[match[1]]) {\n      return;\n   }\n\n   statusUpdate[match[1]](status, value);\n}\n\nconst statusUpdate: {[key: string]: (status: DiffResult, value: number) => void} = {\n   file (status, value) {\n      status.changed = value;\n   },\n   deletion (status, value) {\n      status.deletions = value;\n   },\n   insertion (status, value) {\n      status.insertions = value;\n   }\n}\n\nfunction textFileChange(input: string, {files}: DiffResult) {\n   const line = input.trim().match(/^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/);\n\n   if (line) {\n      var alterations = (line[3] || '').trim();\n      files.push({\n         file: line[1].trim(),\n         changes: parseInt(line[2], 10),\n         insertions: alterations.replace(/-/g, '').length,\n         deletions: alterations.replace(/\\+/g, '').length,\n         binary: false\n      });\n\n      return true;\n   }\n\n   return false\n}\n\nfunction binaryFileChange(input: string, {files}: DiffResult) {\n   const line = input.match(/^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);\n   if (line) {\n      files.push({\n         file: line[1].trim(),\n         before: +line[2],\n         after: +line[3],\n         binary: true\n      });\n      return true;\n   }\n   return false;\n}\n", "import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { parseDiffResult } from './parse-diff-summary';\n\nexport const START_BOUNDARY = '\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ';\n\nexport const COMMIT_BOUNDARY = ' \u00F2\u00F2';\n\nexport const SPLITTER = ' \u00F2 ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce((line, field, index) => {\n      line[field] = tokens[index] || '';\n      return line;\n   }, Object.create({diff: null}) as any);\n}\n\nexport function createListLogSummaryParser<T = any> (splitter = SPLITTER, fields = defaultFieldNames) {\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(stdOut, true, START_BOUNDARY)\n         .map(function (item) {\n            const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n            const listLogLine: T & ListLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n\n            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n               listLogLine.diff = parseDiffResult(lineDetail[1]);\n            }\n\n            return listLogLine;\n         });\n\n      return {\n         all,\n         latest: all.length && all[0] || null,\n         total: all.length,\n      };\n   }\n}\n", "import { Options, StringTask } from '../types';\nimport { LogResult, SimpleGit } from '../../../typings';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[]\n}\n\nfunction prettyFormat(format: Record<string, string | unknown>, splitter: string): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [\n      fields, formatStr.join(splitter)\n   ];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(opt: Options | LogOptions<T> = {}, customArgs: string[] = []): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n      hash: '%H',\n      date: opt.strictDate === false ? '%ai' : '%aI',\n      message: '%s',\n      refs: '%D',\n      body: opt.multiLine ? '%B' : '%b',\n      author_name: opt.mailMap !== false ? '%aN' : '%an',\n      author_email: opt.mailMap !== false ? '%aE' : '%ae'\n   };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from && opt.to) {\n      const rangeOperator = (opt.symmetric !== false) ? '...' : '..';\n      suffix.push(`${opt.from}${rangeOperator}${opt.to}`);\n   }\n\n   if (filterString(opt.file)) {\n      suffix.push('--follow', opt.file);\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [\n         ...command,\n         ...suffix,\n      ],\n   };\n}\n\nexport function logTask<T>(splitter: string, fields: string[], customArgs: string[]): StringTask<LogResult<T>> {\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser: createListLogSummaryParser(splitter, fields),\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(...rest) ||\n            createLogTask(parseLogOptions<T>(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray)))\n\n         return this._runTask(task, next);\n      }\n   }\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`)\n      );\n   }\n}\n", "import { MergeConflict, MergeConflictDeletion, MergeDetail, MergeResultStatus } from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion,\n   ) {\n   }\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n\n", "import { PullDetailFileChanges, PullDetailSummary, PullFailedResult, PullResult } from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n\n", "import { RemoteMessageResult, RemoteMessages, RemoteMessagesObjectEnumeration } from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(remoteMessages: T): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: {count: 0, delta: 0},\n      total: {count: 0, delta: 0}\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber(count && count[1] || '0'),\n      delta: asNumber(delta && delta[1] || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n   }),\n];\n", "import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n   }),\n   ...remoteMessagesObjectParsers,\n   new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n   }),\n   new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n         count: asNumber(count),\n         summary,\n         url,\n      };\n   }),\n];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string, stdErr: string,\n): RemoteMessageResult {\n   return parseStringResponse({remoteMessages: new RemoteMessageSummary() as T}, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n", "import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append((action === 'create') ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n   }),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, stdOut, stdErr);\n}\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr),\n   );\n}\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, stdOut, stdErr);\n\n   return pullError.message && pullError;\n}\n", "import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {deleteRef}));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      parseMergeDetail(stdOut, stdErr),\n      parsePullResult(stdOut, stdErr),\n   );\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n}\n", "import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      }\n   }\n}\n", "import { PushDetail, PushResult, PushResultPushedItem, PushResultRemoteMessages } from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      }\n   }),\n   new LineParser(/^[*-=]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = {\n         ...(result.branch || {}),\n         local,\n         remote,\n         remoteName,\n      };\n   }),\n   new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n         head: {\n            local,\n            remote,\n         },\n         hash: {\n            from,\n            to,\n         },\n      };\n   }),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n}\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({pushed: []}, parsers, stdOut, stdErr);\n}\n", "import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string, branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { FileStatusResult } from '../../../typings/response';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n\n   public readonly from: string | undefined;\n\n   constructor (\n      public path: string,\n      public index: string,\n      public working_dir: string) {\n\n      if ('R' === (index + working_dir)) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { append } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   }\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const detail = /^(.+) -> (.+)$/.exec(line);\n\n   if (!detail) {\n      return {\n         from: line, to: line\n      };\n   }\n\n   return {\n      from: String(detail[1]),\n      to: String(detail[2]),\n   };\n}\n\nfunction parser(indexX: PorcelainFileStatus, indexY: PorcelainFileStatus, handler: StatusLineParser): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map(y => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => append(result.created, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => append(result.deleted, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file)),\n\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => append(result.created, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n\n   parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => append(result.modified, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => append(result.not_added, file)),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n\n   ['##', (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n\n      result.detached = /\\(no branch\\)/.test(line);\n   }]\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.trim().split('\\n');\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l; i++) {\n      splitLine(status, lines[i]);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path, index, workingDir));\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   return {\n      format: 'utf-8',\n      commands: ['status', '--porcelain', '-b', '-u', ...customArgs],\n      parser(text: string) {\n         return parseStatusSummary(text);\n      }\n   }\n}\n", "import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport config from './tasks/config';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { asArray, filterString, filterType, getTrailingOptions, trailingFunctionArgument } from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n\n   constructor(private _executor: SimpleGitExecutor) {\n   }\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: {value: promise.then.bind(promise)},\n         catch: {value: promise.catch.bind(promise)},\n         _executor: {value: chain},\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   cwd(directory: string | { path: string, root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(configurationErrorTask(\n            `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n         ));\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false),\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments),\n      );\n\n      return this._runTask(\n         task,\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   status() {\n      return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n   }\n}\n\nObject.assign(SimpleGitApi.prototype, config(), grep(), log());\n", "import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {id: number};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const {promise, done} = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   }\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const {promise, id} = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'> &\n   OptionFlags<\n      '--whitespace',\n      'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory',\n      string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n", "import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess (branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch, hash, success: true,\n   };\n}\n\nexport function branchDeletionFailure (branch: string): BranchSingleDeleteFailure {\n   return {\n      branch, hash: null, success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure (test: BranchSingleDeleteResult): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n", "import { BranchMultiDeleteResult } from '../../../typings';\nimport { BranchDeletionBatch, branchDeletionFailure, branchDeletionSuccess } from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (stdOut, stdErr) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, stdOut, stdErr);\n}\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n", "import { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(current: boolean, detached: boolean, name: string, commit: string, label: string) {\n      if (current) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: current,\n         name: name,\n         commit: commit,\n         label: label\n      };\n   }\n}\n\n", "import { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(/^(\\*\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         true,\n         name, commit, label\n      );\n   }),\n   new LineParser(/^(\\*\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         false,\n         name, commit, label\n      );\n   })\n];\n\nexport function parseBranchSummary (stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n", "import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some(command => deleteCommands.includes(command));\n}\n\nexport function branchTask(customArgs: string[]): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   }\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   }\n}\n\nexport function deleteBranchesTask(branches: string[], forceDelete = false): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({exitCode, stdOut}, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   }\n}\n\nexport function deleteBranchTask(branch: string, forceDelete = false): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({exitCode, stdErr, stdOut}, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n", "\n/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text.split(/\\n/g)\n      .map(line => line.trim())\n      .filter(file => !!file);\n};\n", "import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<\n      '--bare' |\n      '--dissociate' |\n      '--mirror' |\n      '--no-checkout' |\n      '--no-remote-submodules' |\n      '--no-shallow-submodules' |\n      '--no-single-branch' |\n      '--no-tags' |\n      '--remote-submodules' |\n      '--single-branch' |\n      '--shallow-submodules' |\n      '--verbose'\n      > &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<'--branch' | '--origin' | '--recurse-submodules' | '--separate-git-dir' | '--shallow-exclude' | '--shallow-since' | '--template', string>\n\nexport function cloneTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> {\n   const commands = ['clone', ...customArgs];\n   if (typeof repo === 'string') {\n      commands.push(repo);\n   }\n   if (typeof directory === 'string') {\n      commands.push(directory);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> {\n   append(customArgs,'--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n", "import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim()\n      };\n   }),\n   new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n   }),\n   new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === '-') {\n         result.summary.deletions = count;\n      } else if (direction === '+') {\n         result.summary.insertions = count;\n      }\n   }),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n", "import { CommitResult } from '../../../typings';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport { StringTask } from '../types';\n\nexport function commitTask(message: string[], files: string[], customArgs: string[]): StringTask<CommitResult> {\n   const commands: string[] = ['commit'];\n\n   message.forEach((m) => commands.push('-m', m));\n\n   commands.push(\n      ...files,\n      ...customArgs,\n   );\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   }\n}\n", "import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { parseDiffResult } from '../parsers/parse-diff-summary';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> {\n   return {\n      commands: ['diff', '--stat=4096', ...customArgs],\n      format: 'utf-8',\n      parser (stdOut) {\n         return parseDiffResult(stdOut);\n      }\n   }\n}\n", "import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) =>{\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   })\n];\n\nexport function parseFetchResult (stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n   };\n   return parseStringResponse(result, parsers, stdOut, stdErr);\n}\n", "import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(remote: string, branch: string, customArgs: string[]): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   }\n}\n", "import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({from, to});\n   }),\n];\n\nexport function parseMoveResult (stdOut: string): MoveResult {\n   return parseStringResponse({moves: []}, parsers, stdOut);\n}\n", "import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n", "import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(remote: Maybe<string>, branch: Maybe<string>, customArgs: string[]): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      }\n   }\n}\n", "import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes (text: string): RemoteWithoutRefs[] {\n   const remotes: {[name: string]: RemoteWithoutRefs} = {};\n\n   forEach(text, ([name]) => remotes[name] = { name });\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose (text: string): RemoteWithRefs[] {\n   const remotes: {[name: string]: RemoteWithRefs} = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n", "import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(remoteName: string, remoteRepo: string, customArgs: string[] = []): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n", "import { LogOptions, LogResult } from '../../../typings';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport { StringTask } from '../types';\nimport { parseLogOptions } from './log';\n\nexport function stashListTask(opt: LogOptions = {}, customArgs: string[]): StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const parser = createListLogSummaryParser(options.splitter, options.fields);\n\n   return {\n      commands: ['stash', 'list', ...options.commands, ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n", "import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined,\n   ) {\n   }\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data\n      .split('\\n')\n      .map(trimmed)\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b:  number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n", "import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask (customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser (text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask (name: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser () {\n         return {name};\n      }\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask (name: string, tagMessage: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser () {\n         return {name};\n      }\n   }\n}\n", "const {GitExecutor} = require('./lib/runners/git-executor');\nconst {SimpleGitApi} = require('./lib/simple-git-api');\n\nconst {Scheduler} = require('./lib/runners/scheduler');\nconst {configurationErrorTask} = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} = require('./lib/utils');\nconst {applyPatchTask} = require('./lib/tasks/apply-patch')\nconst {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = require('./lib/tasks/branch');\nconst {checkIgnoreTask} = require('./lib/tasks/check-ignore');\nconst {checkIsRepoTask} = require('./lib/tasks/check-is-repo');\nconst {cloneTask, cloneMirrorTask} = require('./lib/tasks/clone');\nconst {cleanWithOptionsTask, isCleanOptionsArray} = require('./lib/tasks/clean');\nconst {commitTask} = require('./lib/tasks/commit');\nconst {diffSummaryTask} = require('./lib/tasks/diff');\nconst {fetchTask} = require('./lib/tasks/fetch');\nconst {moveTask} = require(\"./lib/tasks/move\");\nconst {pullTask} = require('./lib/tasks/pull');\nconst {pushTagsTask} = require('./lib/tasks/push');\nconst {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = require('./lib/tasks/remote');\nconst {getResetMode, resetTask} = require('./lib/tasks/reset');\nconst {stashListTask} = require('./lib/tasks/stash-list');\nconst {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = require('./lib/tasks/sub-module');\nconst {addAnnotatedTagTask, addTagTask, tagListTask} = require('./lib/tasks/tag');\nconst {straightThroughBufferTask, straightThroughStringTask} = require('./lib/tasks/task');\n\nfunction Git (options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary, options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses), plugins,\n   );\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         filterArray(options) && options || []\n      ),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nfunction createCloneTask (api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Commits changes in the current working directory - when specific file paths are supplied, only changes on those\n * files will be committed.\n *\n * @param {string|string[]} message\n * @param {string|string[]} [files]\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.commit = function (message, files, options, then) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (!filterStringOrStringArray(message)) {\n      return this._runTask(\n         configurationErrorTask('git.commit: requires the commit message to be supplied as a string/string[]'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      commitTask(\n         asArray(message),\n         asArray(filterType(files, filterStringOrStringArray, [])),\n         [...filterType(options, filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n      ),\n      next\n   );\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(\n         configurationErrorTask('Commit must be a string'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task = (typeof name === 'string')\n      ? addTagTask(name)\n      : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n * by supplying either a string or array of strings as the first argument.\n */\nGit.prototype.checkout = function () {\n   const commands = ['checkout', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a remote branch\n *\n * @param {string} branchName name of branch\n * @param {string} startPoint (e.g origin/development)\n * @param {Function} [then]\n */\nGit.prototype.checkoutBranch = function (branchName, startPoint, then) {\n   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));\n};\n\n/**\n * Check out a local branch\n */\nGit.prototype.checkoutLocalBranch = function (branchName, then) {\n   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(\n      branchLocalTask(),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(\n      ...getTrailingOptions(arguments, 0, true),\n   );\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next,\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(\n      addSubModuleTask(repo, path),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(\n      removeRemoteTask(remoteName),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(\n      getRemotesTask(verbose === true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(\n      straightThroughStringTask(command),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler,\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task = format === 'buffer'\n      ? straightThroughBufferTask(command)\n      : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask('git.diff: supplying options as a single string is no longer supported, switch to an array of strings')\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n}\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Show various types of objects, for example the file at a certain commit\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.show = function (options, then) {\n   return this._runTask(\n      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser () {\n         if (typeof then === 'function') {\n            then();\n         }\n      }\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nmodule.exports = Git;\n", "import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n\n   constructor (\n      public readonly config: SimpleGitOptions,\n      message: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n};\n\n// export const api = {\n//    CheckRepoActions,\n//    CleanOptions,\n//    GitConfigScope,\n//    GitConstructError,\n//    GitError,\n//    GitPluginError,\n//    GitResponseError,\n//    ResetMode,\n//    TaskConfigurationError,\n//    grepQueryBuilder,\n// };\n", "import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string,\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(configuration: string[]): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n", "import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n                                             onClose = true,\n                                             onExit = 50\n                                          }: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(flag: boolean | number, event: DeferredPromise<void>, timeout: DeferredPromise<void>) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, {spawned, close}) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try{\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         }\n         catch (err) {\n            close(events.exitCode, err);\n         }\n      }\n   }\n}\n", "import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError (result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage (result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler (overwrite = false, isError = isTaskError, errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage) {\n\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(config: SimpleGitPluginConfig['errors']): SimpleGitPlugin<'task.error'> {\n\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return {error: new GitError(undefined, error.toString('utf-8'))};\n         }\n\n         return {\n            error\n         };\n      },\n   };\n\n}\n", "import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach(plugin => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach(plugin => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(type: T, data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      }\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      }\n   }\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage (input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n", "import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(spawnOptions: Partial<SpawnOptions>): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return {...options, ...data};\n      },\n   };\n}\n", "import { SimpleGitOptions } from '../types';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({block}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n            }\n\n            function kill() {\n               stop()\n               context.kill(\n                  new GitPluginError(undefined, 'timeout', `block timeout reached`)\n               );\n            }\n\n            context.spawned.stdout?.on('data', wait);\n            context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         }\n      }\n   }\n\n}\n", "import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin\n} from './plugins';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T): T & { __esModule: true, default: T } {\n   return Object.defineProperties(defaultExport, {\n      __esModule: {value: true},\n      default: {value: defaultExport},\n   });\n}\n\nexport function gitExportFactory<T = {}>(factory: SimpleGitFactory, extra: T) {\n   return Object.assign(function (...args: Parameters<SimpleGitFactory>) {\n         return factory.apply(null, args);\n      },\n      api,\n      extra || {},\n   );\n}\n\nexport function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      baseDir && (typeof baseDir === 'string' ? {baseDir} : baseDir) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n", "import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = [\n   'customBinary', 'env', 'outputHandler', 'silent',\n];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo'\n];\n\nexport function gitP(...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]): SimpleGit {\n\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api: any, name: string) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n\n      Object.defineProperty(api, name, {\n         enumerable: false,\n         configurable: false,\n         value: git ? valid : alternative,\n      });\n\n      return api;\n   }, {});\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n               'trailing function not allowed in call to ' + fn);\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n", "import { gitInstanceFactory } from './lib/git-factory';\n\nexport {gitP} from './lib/runners/promise-wrapped';\nexport * from './lib/api';\n\nexport default gitInstanceFactory;\n"],
  "mappings": "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",
  "names": []
}
