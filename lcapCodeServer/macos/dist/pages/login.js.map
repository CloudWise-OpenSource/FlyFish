{"version":3,"sources":["../common/util.ts","pages/login.ts"],"names":[],"mappings":";AA2HA,aAAA,IAAA,EAAA,MAAA,KAAA,UAAA,WAAA,OAAA,EAAA,OAAA,QAAA,SAAA,GAAA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,OAAA,EAAA,EAAA,IAAA,IAAA,IAAA,KAAA,EAAA,UAAA,GAAA,OAAA,UAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,IAAA,MAAA,KAAA,YAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,SAAA,QAAA,eAAA,QAAA,SAAA,QAAA,WAAA,QAAA,YAAA,QAAA,YAAA,QAAA,UAAA,QAAA,aAAA,QAAA,OAAA,QAAA,WAAA,EAvGO,IAAM,EAAQ,SAAC,EAAa,GAC3B,IAAA,EAAQ,EAAI,QAAQ,GACnB,OAAW,IAAX,EAAe,CAAC,EAAI,UAAU,EAAG,GAAO,OAAQ,EAAI,UAAU,EAAQ,IAAM,CAAC,EAAK,KAF9E,QAAA,MAAK,EASX,IAAM,EAAS,SAAC,EAAe,GAAyB,OAAU,IAAV,EAAc,EAAS,EAAG,KAA5E,QAAA,OAAM,EAEZ,IAAM,EAAe,SAAC,QAAA,IAAA,IAAA,EAAA,IACrB,IAAA,EAAW,iEACV,OAAA,MAAM,GACV,KAAK,GACL,IAAI,WAAM,OAAA,EAAS,KAAK,MAAM,KAAK,SAAW,EAAS,WACvD,KAAK,KALG,QAAA,aAAY,EAWlB,IAAM,EAAY,SAAC,EAAa,GAC9B,YAD8B,IAAA,IAAA,GAAA,GAC9B,EAAI,QAAQ,SAAU,KAAK,QAAQ,OAAQ,EAAe,IAAM,KAD5D,QAAA,UAAS,EAOf,IAAM,EAAc,SAAC,GACnB,OAAA,EAAI,QAAQ,aAAc,KADtB,QAAA,YAAW,EAQjB,IAAM,EAAc,SAAC,GAEtB,IAAC,GAAQ,EAAK,WAAW,KACpB,OAAA,MAAA,EAAA,EAAQ,GAEX,IAAA,EAAQ,SAAS,SAAS,MAAM,KACtC,EAAM,EAAM,OAAS,GAAK,EACpB,IAAA,EAAM,IAAI,IAAI,SAAS,OAAS,IAAM,EAAM,KAAK,MAChD,OAAA,QAAA,UAAU,EAAI,WARV,QAAA,YAAW,EAcjB,IAAM,EAAa,WACpB,IAAA,EACA,IACF,EAAU,KAAK,MAAM,SAAS,eAAe,iBAAkB,aAAa,kBAC5E,MAAO,GACP,EAAU,GAMN,IACA,EADS,IAAI,gBAAgB,SAAS,QACnB,IAAI,WAWtB,OAVH,IACF,EAAO,EAAA,EAAA,GACF,GACA,KAAK,MAAM,KAIlB,EAAQ,KAAO,QAAA,YAAY,EAAQ,MACnC,EAAQ,aAAe,QAAA,YAAY,EAAQ,cAEpC,GAvBI,QAAA,WAAU,EA8BhB,IAAM,EAAW,SAAI,GACtB,OAAA,MAAM,QAAQ,GACT,OAEY,IAAV,EACF,GAEF,CAAC,IAPG,QAAA,SAAQ,EAad,IAAM,EAAiB,SAAC,GACzB,OAAA,MAAM,QAAQ,GACT,EAAM,GAGS,iBAAV,EAAqB,OAAQ,GAI7C,SAAgB,EAAS,EAA0C,EAAgB,GAC7E,aAAe,MACjB,EAAO,MAAS,EAAM,KAAK,EAAI,QAAO,IAAI,EAAI,OAE9C,EAAO,MAAS,EAAM,KAAK,GAblB,QAAA,eAAc,EAS3B,QAAA,SAAA;;ACrHC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAND,IAAA,EAAA,QAAA,qBAEM,EAAU,EAAA,aACV,EAAK,SAAS,eAAe,QAC/B,IACF,EAAG,MAAQ,EAAQ","file":"login.js","sourceRoot":"../src/browser","sourcesContent":["/*\n * This file exists in two locations:\n * - src/common/util.ts\n * - lib/vscode/src/vs/server/common/util.ts\n * The second is a symlink to the first.\n */\n\n/**\n * Base options included on every page.\n */\nexport interface Options {\n  base: string\n  csStaticBase: string\n  logLevel: number\n}\n\n/**\n * Split a string up to the delimiter. If the delimiter doesn't exist the first\n * item will have all the text and the second item will be an empty string.\n */\nexport const split = (str: string, delimiter: string): [string, string] => {\n  const index = str.indexOf(delimiter)\n  return index !== -1 ? [str.substring(0, index).trim(), str.substring(index + 1)] : [str, \"\"]\n}\n\n/**\n * Appends an 's' to the provided string if count is greater than one;\n * otherwise the string is returned\n */\nexport const plural = (count: number, str: string): string => (count === 1 ? str : `${str}s`)\n\nexport const generateUuid = (length = 24): string => {\n  const possible = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n  return Array(length)\n    .fill(1)\n    .map(() => possible[Math.floor(Math.random() * possible.length)])\n    .join(\"\")\n}\n\n/**\n * Remove extra slashes in a URL.\n */\nexport const normalize = (url: string, keepTrailing = false): string => {\n  return url.replace(/\\/\\/+/g, \"/\").replace(/\\/+$/, keepTrailing ? \"/\" : \"\")\n}\n\n/**\n * Remove leading and trailing slashes.\n */\nexport const trimSlashes = (url: string): string => {\n  return url.replace(/^\\/+|\\/+$/g, \"\")\n}\n\n/**\n * Resolve a relative base against the window location. This is used for\n * anything that doesn't work with a relative path.\n */\nexport const resolveBase = (base?: string): string => {\n  // After resolving the base will either start with / or be an empty string.\n  if (!base || base.startsWith(\"/\")) {\n    return base ?? \"\"\n  }\n  const parts = location.pathname.split(\"/\")\n  parts[parts.length - 1] = base\n  const url = new URL(location.origin + \"/\" + parts.join(\"/\"))\n  return normalize(url.pathname)\n}\n\n/**\n * Get options embedded in the HTML or query params.\n */\nexport const getOptions = <T extends Options>(): T => {\n  let options: T\n  try {\n    options = JSON.parse(document.getElementById(\"coder-options\")!.getAttribute(\"data-settings\")!)\n  } catch (error) {\n    options = {} as T\n  }\n\n  // You can also pass options in stringified form to the options query\n  // variable. Options provided here will override the ones in the options\n  // element.\n  const params = new URLSearchParams(location.search)\n  const queryOpts = params.get(\"options\")\n  if (queryOpts) {\n    options = {\n      ...options,\n      ...JSON.parse(queryOpts),\n    }\n  }\n\n  options.base = resolveBase(options.base)\n  options.csStaticBase = resolveBase(options.csStaticBase)\n\n  return options\n}\n\n/**\n * Wrap the value in an array if it's not already an array. If the value is\n * undefined return an empty array.\n */\nexport const arrayify = <T>(value?: T | T[]): T[] => {\n  if (Array.isArray(value)) {\n    return value\n  }\n  if (typeof value === \"undefined\") {\n    return []\n  }\n  return [value]\n}\n\n/**\n * Get the first string. If there's no string return undefined.\n */\nexport const getFirstString = (value: string | string[] | object | undefined): string | undefined => {\n  if (Array.isArray(value)) {\n    return value[0]\n  }\n\n  return typeof value === \"string\" ? value : undefined\n}\n\n// TODO: Might make sense to add Error handling to the logger itself.\nexport function logError(logger: { error: (msg: string) => void }, prefix: string, err: Error | string): void {\n  if (err instanceof Error) {\n    logger.error(`${prefix}: ${err.message} ${err.stack}`)\n  } else {\n    logger.error(`${prefix}: ${err}`)\n  }\n}\n","import { getOptions } from \"../../common/util\"\n\nconst options = getOptions()\nconst el = document.getElementById(\"base\") as HTMLInputElement\nif (el) {\n  el.value = options.base\n}\n"]}